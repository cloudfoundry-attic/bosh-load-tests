// Code generated by counterfeiter. DO NOT EDIT.
package clirunnerfakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/bosh-load-tests/action/clirunner"
)

type FakeRunner struct {
	SetEnvStub        func(envName string)
	setEnvMutex       sync.RWMutex
	setEnvArgsForCall []struct {
		envName string
	}
	RunInDirWithArgsStub        func(dir string, args ...string) error
	runInDirWithArgsMutex       sync.RWMutex
	runInDirWithArgsArgsForCall []struct {
		dir  string
		args []string
	}
	runInDirWithArgsReturns struct {
		result1 error
	}
	runInDirWithArgsReturnsOnCall map[int]struct {
		result1 error
	}
	RunWithArgsStub        func(args ...string) error
	runWithArgsMutex       sync.RWMutex
	runWithArgsArgsForCall []struct {
		args []string
	}
	runWithArgsReturns struct {
		result1 error
	}
	runWithArgsReturnsOnCall map[int]struct {
		result1 error
	}
	RunWithOutputStub        func(args ...string) (string, error)
	runWithOutputMutex       sync.RWMutex
	runWithOutputArgsForCall []struct {
		args []string
	}
	runWithOutputReturns struct {
		result1 string
		result2 error
	}
	runWithOutputReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRunner) SetEnv(envName string) {
	fake.setEnvMutex.Lock()
	fake.setEnvArgsForCall = append(fake.setEnvArgsForCall, struct {
		envName string
	}{envName})
	fake.recordInvocation("SetEnv", []interface{}{envName})
	fake.setEnvMutex.Unlock()
	if fake.SetEnvStub != nil {
		fake.SetEnvStub(envName)
	}
}

func (fake *FakeRunner) SetEnvCallCount() int {
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	return len(fake.setEnvArgsForCall)
}

func (fake *FakeRunner) SetEnvArgsForCall(i int) string {
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	return fake.setEnvArgsForCall[i].envName
}

func (fake *FakeRunner) RunInDirWithArgs(dir string, args ...string) error {
	fake.runInDirWithArgsMutex.Lock()
	ret, specificReturn := fake.runInDirWithArgsReturnsOnCall[len(fake.runInDirWithArgsArgsForCall)]
	fake.runInDirWithArgsArgsForCall = append(fake.runInDirWithArgsArgsForCall, struct {
		dir  string
		args []string
	}{dir, args})
	fake.recordInvocation("RunInDirWithArgs", []interface{}{dir, args})
	fake.runInDirWithArgsMutex.Unlock()
	if fake.RunInDirWithArgsStub != nil {
		return fake.RunInDirWithArgsStub(dir, args...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.runInDirWithArgsReturns.result1
}

func (fake *FakeRunner) RunInDirWithArgsCallCount() int {
	fake.runInDirWithArgsMutex.RLock()
	defer fake.runInDirWithArgsMutex.RUnlock()
	return len(fake.runInDirWithArgsArgsForCall)
}

func (fake *FakeRunner) RunInDirWithArgsArgsForCall(i int) (string, []string) {
	fake.runInDirWithArgsMutex.RLock()
	defer fake.runInDirWithArgsMutex.RUnlock()
	return fake.runInDirWithArgsArgsForCall[i].dir, fake.runInDirWithArgsArgsForCall[i].args
}

func (fake *FakeRunner) RunInDirWithArgsReturns(result1 error) {
	fake.RunInDirWithArgsStub = nil
	fake.runInDirWithArgsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRunner) RunInDirWithArgsReturnsOnCall(i int, result1 error) {
	fake.RunInDirWithArgsStub = nil
	if fake.runInDirWithArgsReturnsOnCall == nil {
		fake.runInDirWithArgsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runInDirWithArgsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRunner) RunWithArgs(args ...string) error {
	fake.runWithArgsMutex.Lock()
	ret, specificReturn := fake.runWithArgsReturnsOnCall[len(fake.runWithArgsArgsForCall)]
	fake.runWithArgsArgsForCall = append(fake.runWithArgsArgsForCall, struct {
		args []string
	}{args})
	fake.recordInvocation("RunWithArgs", []interface{}{args})
	fake.runWithArgsMutex.Unlock()
	if fake.RunWithArgsStub != nil {
		return fake.RunWithArgsStub(args...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.runWithArgsReturns.result1
}

func (fake *FakeRunner) RunWithArgsCallCount() int {
	fake.runWithArgsMutex.RLock()
	defer fake.runWithArgsMutex.RUnlock()
	return len(fake.runWithArgsArgsForCall)
}

func (fake *FakeRunner) RunWithArgsArgsForCall(i int) []string {
	fake.runWithArgsMutex.RLock()
	defer fake.runWithArgsMutex.RUnlock()
	return fake.runWithArgsArgsForCall[i].args
}

func (fake *FakeRunner) RunWithArgsReturns(result1 error) {
	fake.RunWithArgsStub = nil
	fake.runWithArgsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRunner) RunWithArgsReturnsOnCall(i int, result1 error) {
	fake.RunWithArgsStub = nil
	if fake.runWithArgsReturnsOnCall == nil {
		fake.runWithArgsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runWithArgsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRunner) RunWithOutput(args ...string) (string, error) {
	fake.runWithOutputMutex.Lock()
	ret, specificReturn := fake.runWithOutputReturnsOnCall[len(fake.runWithOutputArgsForCall)]
	fake.runWithOutputArgsForCall = append(fake.runWithOutputArgsForCall, struct {
		args []string
	}{args})
	fake.recordInvocation("RunWithOutput", []interface{}{args})
	fake.runWithOutputMutex.Unlock()
	if fake.RunWithOutputStub != nil {
		return fake.RunWithOutputStub(args...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.runWithOutputReturns.result1, fake.runWithOutputReturns.result2
}

func (fake *FakeRunner) RunWithOutputCallCount() int {
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	return len(fake.runWithOutputArgsForCall)
}

func (fake *FakeRunner) RunWithOutputArgsForCall(i int) []string {
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	return fake.runWithOutputArgsForCall[i].args
}

func (fake *FakeRunner) RunWithOutputReturns(result1 string, result2 error) {
	fake.RunWithOutputStub = nil
	fake.runWithOutputReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRunner) RunWithOutputReturnsOnCall(i int, result1 string, result2 error) {
	fake.RunWithOutputStub = nil
	if fake.runWithOutputReturnsOnCall == nil {
		fake.runWithOutputReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.runWithOutputReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRunner) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	fake.runInDirWithArgsMutex.RLock()
	defer fake.runInDirWithArgsMutex.RUnlock()
	fake.runWithArgsMutex.RLock()
	defer fake.runWithArgsMutex.RUnlock()
	fake.runWithOutputMutex.RLock()
	defer fake.runWithOutputMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeRunner) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ clirunner.Runner = new(FakeRunner)
